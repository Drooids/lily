<html>
  <head>
    <meta charset="UTF-8" />
    <script src="modernizr-1.5.js"></script>
    <link href="lily_style.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <header>
      <img src="logo.png">
      <h1>Lily</h1>
    </header>

    <aside>
      <ul>
        <li>Home</li>
        <li><a href="index.html">Introducing Lily</a></li>
        <li><a href="getting_started.html">Getting Started</a></li>
        <li><a href="tryit.html">Try it</a></li>
      </ul>
      <ul>
        <li>Core</li>
        <li><a href="syntax.html">Syntax</a></li>
        <li><a href="control_flow.html">Control flow</a></li>
        <li><a href="functions.html">Functions</a></li>
        <li><a href="builtin_types.html">Builtin types</a></li>
        <li><a href="generics.html">Generics</a></li>
        <li><a href="classes.html">Classes</a></li>
        <li><a href="enums.html">Enums</a></li>
        <li><a href="lambdas.html">Lambdas</a></li>
        <li><a href="error_handling.html">Error Handling</a></li>
        <li><a href="import.html">Importing</a></li>
      </ul>
      <ul>
        <li>Class Reference</li>
        <li><a href="boolean_type.html">boolean</a></li>
        <li><a href="integer_type.html">integer</a></li>
        <li><a href="double_type.html">double</a></li>
        <li><a href="bytestring_type.html">bytestring</a></li>
        <li><a href="string_type.html">string</a></li>
        <li><a href="function_type.html">function</a></li>
        <li><a href="list_type.html">list</a></li>
        <li><a href="hash_type.html">hash</a></li>
        <li><a href="tuple_type.html">tuple</a></li>
        <li><a href="dynamic_type.html">Dynamic</a></li>
        <li><a href="exception_type.html">Exception</a></li>
        <li><a href="tainted_type.html">Tainted</a></li>
        <li><a href="option_type.html">Option</a></li>
      </ul>
      <ul>
        <li>Reference</li>
        <li><a href="sys_package.html">sys</a></li>
        <li><a href="server_package.html">server</a></li>
        <li><a href="postgre_package.html">postgre</a></li>
        <li><a href="builtins.html">builtins</a></li>
      </ul>
    </aside>
   <article>
     <section>
<h1>Builtin Types</h1>
<p>Lily comes with a handful of types baked into it that are available from any scope. For now at least, these classes <strong>cannot</strong> be inherited from (aside from Exception).</p>
<h1>boolean</h1>
<p>A value that is either <code>true</code> or <code>false</code>.</p>
<h1>integer</h1>
<p>This type is a signed 64-bit int. It has a range of +9,223,372,036,854,775,807 to to -9,223,372,036,854,775,808. Currently, operations in Lily do not check for overflow, and thus behavior during overflow is undefined. Here are some examples of integer literals:</p>
<pre><code>123
-456
# Octal
0t7
# Hex
0xdeadbeef
# Binary
0b101010
</code></pre>

<h1>double</h1>
<p>This type is a C double. It's minimum and maximum values are...really big. Negative and positive values are allowed, as well as decimal values. Here are some <code>double</code> literals.</p>
<pre><code>1.5
1e-1
-1.0
</code></pre>

<p>Note: Lily will not allow integer literals to be assigned to values which have specified a want for a double.</p>
<h1>string</h1>
<p>Lily's strings are utf-8 clean, and always 0-terminated. The methods of the string class are all utf-8 aware (so, for example, split is able to split on utf-8 codepoints, instead of by bytes). You can subscript from a string, and the index will be based off of codepoints, instead of bytes. The string class is also immutable: All string methods will create a new string instead of modifying the existing underlying string.</p>
<p>String literals begin and end with the double quote (<code>"</code>). Lily supports the following escape sequences within a string.</p>
<pre><code>\n:   Newline
\r:   Carriage Return
\t:   Tab
\':   ' (single quote)
\&quot;:   &quot; (double quote)
\\:   \
\nnn: nnn represents three decimal digits.
      Values allowed are \001...\127
</code></pre>

<h1>bytestring</h1>
<p>Sometimes you need to interface with something that may give back strings with embedded \0's, or may kick back invalid utf-8. For those situations, Lily provides a bytestrings. This class is length counted, therein allowing embedded zeroes. This class provides a method to convert to a string, allowing string to be a 'pure', valid string, and for bytestring to handle the nastier cases.</p>
<p>Bytestring literals are like string literals, except they start with 'B' exactly before the opening double quote (<code>"</code>). Bytestring literals support all escape codes that string literals do, with the addition that bytestring literals allow <code>\nnn</code> escape sequences from <code>\001</code> to <code>\255</code></p>
<h1>functions</h1>
<p>Lily's functions are considered first-class. This means they can be assigned to vars, passed as parameters, inserted into lists, and more. There are no function literals, but there are lambdas, which are discussed later. The <code>define</code> keyword is responsible for creating new functions.</p>
<h1>Dynamic</h1>
<p>This class exists to hold values of other classes. <code>Dynamic</code> is useful because instances of <code>Dynamic</code> are not constrained to any single type. This allows a <code>list</code> to hold a mixture of values (with the actual values hidden behind <code>Dynamic</code> instances).</p>
<p>Fetching a value from Dynamic is done through typecasting. Since Lily strives to be a safe language, typecasts will yield either an <code>Option[&lt;type&gt;]</code> which holds a <code>Some(&lt;type&gt;)</code> on success and <code>None</code> on failure.</p>
<p>There are occasionally cases where Lily is not able to use inference to determine all the subtypes that a value should have. In such cases, <code>Dynamic</code> is used as a filler type, since it permits a wide range of values.</p>
<h1>list</h1>
<p>The list class is Lily's most basic container type. Lily's lists are qualified by a single type, which is the type expected for elements. For example, the type <code>list[integer]</code> denotes a list that is supposed to contain just integers. <code>list[function( =&gt; integer)]</code> would be a list that is only supposed to hold functions which take no parameters, but return an integer. Lily's lists are flexible and can be designated to hold any type.</p>
<pre><code>var a = [1, 2, 3]

var b = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]

var c = [b, b]

# Subscript indexes are 0-based.
a[0] = 4

# Subscript get/set is an error if out of bounds.
# a[4] = 4

# Negative subscripts are allowed.
var d = a[-1]

# With nothing to infer from, this has the type `list[Dynamic]`
var e = []
</code></pre>

<p>Lily attempts to do some type inference, when it can:</p>
<pre><code>define f : list[integer]
{
    # Inferred as an empty list[integer]
    return []
}

# Inferred as an empty list[list[integer]]
var v: list[list[integer]] = []
</code></pre>

<h1>hash</h1>
<p>This is a basic hash collection, representing a mapping from a key to a value. The annotation for this type has the key first, and the value second. Therefore, a hash that maps from string keys to integer values would be written as <code>hash[string, integer]</code>. Hashes are created similar to how lists are created:</p>
<pre><code>var v = [&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3]

# Print the value represented by &quot;a&quot;.
print(v[&quot;a&quot;])

# New values can be added through assignment.
v[&quot;d&quot;] = 4

# With repeats, the right-most value has precedence.
v = [&quot;a&quot; =&gt; 1, &quot;a&quot; =&gt; 2] # Value: &quot;a&quot; =&gt; 2
</code></pre>

<p>For now, only <code>integer</code>, <code>double</code>, and <code>string</code> are considered valid hash keys. In the future, it may be possible to have user-defined classes that are hashable.</p>
<p>It is also worth noting that Lily will insist that, when creating a hash, that there is some common bottom type to all elements in the hash.</p>
<h1>tuple</h1>
<p>Occasionally, it is useful to have a grouping of various different types. This class takes an arbitrary number of types within it, making it useful in situations where there is a need for a 'record' type that holds a bag of types. As with the above mentioned types, the subtypes of tuple are denoted by the square braces that come after the type.</p>
<p>Tuples are similar to lists, but have some interesting differences</p>
<pre><code># &lt;[ ... ]&gt; is the syntax for creating tuples.
var t = &lt;[1, &quot;2&quot;, [3]]&gt;

# Invalid: Empty tuples are not allowed.
# var empty = &lt;[]&gt;

# Tuples are also 0-indexed.
var my_list = t[2]

# Tuple subscripts MUST be literals. This is why:
define subscript(my_tup: tuple[integer, string, list[integer]], x: integer)
{
    # Invalid: Lily has no way of knowing what the resulting type will be.
    # var invalid = my_tup[x]
}
</code></pre>

<h1>file</h1>
<p>It's a file. Files can be opened with <code>file::open</code>, and some basic methods for IO are available on files.</p>
<h1>Exception</h1>
<p>This class defines the most basic kind of raiseable error. This class is covered in more detail in the section about user-defined errors.</p>
     </section>
   </article>
     <footer>
      <p>
Lily is designed by Jesse Ray Adkins (<a href="https://github.com/jesserayadkins">Github</a>,
<a href="http://www.reddit.com/user/jesserayadkins">Reddit</a>).
      </p>
      <br />
      <p>
Logo source: <a href="http://sweetclipart.com/three-white-calla-lilies-1015">here</a>, via <a href="http://sweetclipart.com">sweetclipart.com</a>.
      </p>
    </footer>
</body>
</html>
