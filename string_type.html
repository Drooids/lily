<html>
  <head>
    <meta charset="UTF-8" />
    <script src="modernizr-1.5.js"></script>
    <link href="lily_style.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <header>
      <img src="logo.png">
      <h1>Lily</h1>
    </header>

    <aside>
      <ul>
        <li>Home</li>
        <li><a href="index.html">Introducing Lily</a></li>
        <li><a href="getting_started.html">Getting Started</a></li>
      </ul>
      <ul>
        <li>Core</li>
        <li><a href="syntax.html">Syntax</a></li>
        <li><a href="control_flow.html">Control flow</a></li>
        <li><a href="functions.html">Functions</a></li>
        <li><a href="builtin_types.html">Builtin types</a></li>
        <li><a href="generics.html">Generics</a></li>
        <li><a href="classes.html">Classes</a></li>
        <li><a href="enums.html">Enums</a></li>
        <li><a href="lambdas.html">Lambdas</a></li>
        <li><a href="error_handling.html">Error Handling</a></li>
        <li><a href="import.html">Importing</a></li>
      </ul>
      <ul>
        <li>Class Reference</li>
        <li><a href="boolean_type.html">boolean</a></li>
        <li><a href="integer_type.html">integer</a></li>
        <li><a href="bytestring_type.html">bytestring</a></li>
        <li><a href="string_type.html">string</a></li>
        <li><a href="function_type.html">function</a></li>
        <li><a href="list_type.html">list</a></li>
        <li><a href="hash_type.html">hash</a></li>
        <li><a href="tuple_type.html">tuple</a></li>
        <li><a href="any_type.html">any</a></li>
        <li><a href="exception_type.html">Exception</a></li>
      </ul>
      <ul>
        <li>Reference</li>
        <li><a href="sys.html">sys</a></li>
        <li><a href="server.html">server</a></li>
        <li><a href="postgre.html">postgre</a></li>
        <li><a href="builtins.html">builtins</a></li>
      </ul>
    </aside>
   <article>
     <section>
<h1>string</h1>
<p>The string type is backed by a C string, and guaranteed to be both utf-8 clean and with no embedded zeroes.</p>
<p>It is possible to subscript from a string. Subscripts are done by character, not by byte. As a result, the string <code>"ĀēĪōŪ"</code> has five elements. Subscripts also start from a zero index. It is also to negatively subscript a list, wherein -1 indicates the last element.</p>
<p>Strings are immutable: Standard library functions will always create new copies of a string, instead of modifying an existing one.</p>
<h1>Operations</h1>
<p>Binary: <code>!=</code> <code>==</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></p>
<p>Comparisons and equality for strings are done by comparing the bytes of each string. Comparisons are done using case-sensitive matching. Internally, it just uses C's strcmp.</p>
<h1>Methods</h1>
<p><code>string::concat (self: string, other: string =&gt; string)</code></p>
<p>Return a new string that is a combination of <code>self</code> and <code>other</code>.</p>
<p><code>string::endswith (self: string, other: string =&gt; boolean)</code></p>
<p>Returns <code>true</code> if <code>self</code> ends with <code>other</code>, <code>false</code> otherwise. If <code>other</code> is empty, then the result is always <code>true</code>.</p>
<p><code>string::find (self: string, needle: string =&gt; integer)</code></p>
<p>Attempt to locate <code>needle</code> within <code>self</code>. If <code>needle</code> is found, then the result is the index where <code>needle</code> starts. If it is not found, the result is -1.</p>
<p><code>string::format (self: string, list[any]... =&gt; string)</code></p>
<p>This uses <code>self</code> as a formatting string, with the values coming from whatever extra arguments are passed. The following format specifiers are accepted:</p>
<ul>
<li>
<p><code>%d</code>: Convert an integer value.</p>
</li>
<li>
<p><code>%f</code>: Convert a double value.</p>
</li>
<li>
<p><code>%s</code>: Convert anything to a string. This is currently a work-in-progress, as Lily has a crude mechanism for converting anything into a string. However, because Lily lacks virtual calls, it is unwise to use this for anything but built-in types such as lists and hashes.</p>
</li>
</ul>
<p>If there are more format specifiers than arguments, then <code>ValueError</code> is raised.</p>
<p>It is currently <em>not</em> possible to specify a size along with a format specifier (ex: <code>%3d</code>).</p>
<p><code>string::htmlencode (self: string =&gt; string)</code></p>
<p>Encode a string so that it is suitable for being written to something expecting well-formatted html. <code>&amp;</code> becomes <code>&amp;amp;</code>, <code>&lt;</code> becomes <code>&amp;lt;</code>, <code>&gt;</code> becomes <code>&amp;gt;</code>.</p>
<p><code>string::isalnum (self: string =&gt; boolean)</code></p>
<p>Return <code>true</code> if every character in a string is within a-z or within 0-9, <code>false</code> otherwise.</p>
<p><code>string::isalpha (self: string =&gt; boolean)</code></p>
<p>Return <code>true</code> if every character in a string is within a-z, <code>false</code> otherwise.</p>
<p><code>string::isdigit (self: string =&gt; boolean)</code></p>
<p>Return <code>true</code> if every character in a string is within 0-9, <code>false</code> otherwise.</p>
<p><code>string::isspace (self: string =&gt; boolean)</code></p>
<p>Return <code>true</code> if every character in a string is one of <code>\t\r\n</code>, <code>false</code> otherwise.</p>
<p><code>string::lower (self: string =&gt; string)</code></p>
<p>This returns a string where all characters in the A-Z range are converted into their equivalents within a-z. Unicode characters are untouched.</p>
<p><code>string::lstrip (self: string, to_strip: string =&gt; string)</code></p>
<p>This returns a string where <code>to_strip</code> has been removed from the start of <code>self</code>. If <code>to_strip</code> is an empty string, then the input string is returned as-is.</p>
<p><code>string::rstrip (self: string, to_strip: string =&gt; string)</code></p>
<p>This returns a string where <code>to_strip</code> has been removed from the end of <code>self</code>. If <code>to_strip</code> is an empty string, then the input string is returned as-is.</p>
<p><code>string::split (self: string, *by: string=" " =&gt; list[string])</code></p>
<p>This splits <code>self</code> by each character (not byte) that is within <code>by</code>. By default, it will split just by spaces.</p>
<p>ValueError is raised if <code>by</code> is an empty string.</p>
<p><code>string::startswith (self: string, other: string =&gt; boolean)</code></p>
<p>Returns <code>true</code> if <code>self</code> begins with <code>other</code>, <code>false</code> otherwise. If <code>other</code> is empty, then the result is always <code>true</code>.</p>
<p><code>string::strip (self: string, to_strip: string =&gt; string)</code></p>
<p>This acts as a combination of lstrip and rstrip, returning a string which has <code>to_strip</code> removed from both the start and end of <code>self</code>. If <code>to_strip</code> is an empty string, then the input string is returned as-is.</p>
<p><code>string::to_i (self: string =&gt; integer)</code></p>
<p>This attempts to convert a string into an integer. The function assumes that <code>self</code> describes a decimal value (and not, say, octal or hex). If unable to convert the string to an integer, <code>ValueError</code> is raised.</p>
<p>Examples:</p>
<pre><code># Value: -5
&quot;-5&quot;.to_i()

# Value: 1
&quot;00000001&quot;.to_i()

# Invalid: Hex is not supported
# &quot;0x10&quot;.to_i()

# Invalid: The whole thing must be an integer
# &quot;10cats&quot;.to_i()
</code></pre>

<p><code>string::trim (self: string =&gt; string)</code></p>
<p>This function returns with consecutive whitespace (<code>" \t\r\n"</code>) removed from both the start and end of the string.</p>
<p><code>string::upper (self: string =&gt; string)</code></p>
<p>This returns a string where all characters in the a-z range are converted into their equivalents within A-Z. Unicode characters are untouched.</p>
     </section>
   </article>
     <footer>
      <p>
Lily is designed by Jesse Ray Adkins (<a href="https://github.com/jesserayadkins">Github</a>,
<a href="http://www.reddit.com/user/jesserayadkins">Reddit</a>).
      </p>
      <br />
      <p>
Logo source: <a href="http://sweetclipart.com/three-white-calla-lilies-1015">here</a>, via <a href="http://sweetclipart.com">sweetclipart.com</a>.
      </p>
    </footer>
</body>
</html>
